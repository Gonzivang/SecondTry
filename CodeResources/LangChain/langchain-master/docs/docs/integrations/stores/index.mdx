---
sidebar_position: 1
sidebar_class_name: hidden
---

# Stores

In many different applications, having some sort of key-value storage is helpful. 
In this section, we will look at a few different ways to store key-value pairs
using implementations of the `ByteStore` interface.

## Features (natively supported)

All `ByteStore`s support the following functions, which are used for modifying
**m**ultiple key-value pairs at once:

- `mget(key: Sequence[str]) -> List[Optional[bytes]]`: get the contents of multiple keys, returning `None` if the key does not exist
- `mset(key_value_pairs: Sequence[Tuple[str, bytes]]) -> None`: set the contents of multiple keys
- `mdelete(key: Sequence[str]) -> None`: delete multiple keys
- `yield_keys(prefix: Optional[str] = None) -> Iterator[str]`: yield all keys in the store, optionally filtering by a prefix

## How to pick one

`ByteStore`s are designed to be interchangeable. By default, most dependent integrations
use the `InMemoryByteStore`, which is a simple in-memory key-value store.

However, if you start having other requirements, like massive scalability or persistence,
you can swap out the `ByteStore` implementation with one of the other ones documented
in this section.
